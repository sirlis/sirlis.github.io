<!doctype html>














<!-- `site.alt_lang` can specify a language different from the UI -->
<html lang="zh-CN" 
  
>
  <!-- The Head -->

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta
    name="viewport"
    content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover"
  >

  

  

  
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="人工智能（搜索策略）" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="搜索算法是人工智能领域的核心基础，为智能系统提供了在复杂问题空间中寻找可行解或最优解的能力。从简单的迷宫寻路到复杂的游戏决策，搜索算法构成了许多人工智能应用的基石。" />
<meta property="og:description" content="搜索算法是人工智能领域的核心基础，为智能系统提供了在复杂问题空间中寻找可行解或最优解的能力。从简单的迷宫寻路到复杂的游戏决策，搜索算法构成了许多人工智能应用的基石。" />
<link rel="canonical" href="http://localhost:4000/posts/artificial-intelligence-search-strategy/" />
<meta property="og:url" content="http://localhost:4000/posts/artificial-intelligence-search-strategy/" />
<meta property="og:site_name" content="SIRLIS" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-09-17T09:29:49+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="人工智能（搜索策略）" />
<meta name="twitter:site" content="@none" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-09-22T20:27:56+08:00","datePublished":"2025-09-17T09:29:49+08:00","description":"搜索算法是人工智能领域的核心基础，为智能系统提供了在复杂问题空间中寻找可行解或最优解的能力。从简单的迷宫寻路到复杂的游戏决策，搜索算法构成了许多人工智能应用的基石。","headline":"人工智能（搜索策略）","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/posts/artificial-intelligence-search-strategy/"},"url":"http://localhost:4000/posts/artificial-intelligence-search-strategy/"}</script>
<!-- End Jekyll SEO tag -->

  

  <title>人工智能（搜索策略） | SIRLIS
  </title>

  <!--
  The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps
  Generated by: https://realfavicongenerator.net/
-->



<link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png">
<link rel="manifest" href="/assets/img/favicons/site.webmanifest">
<link rel="shortcut icon" href="/assets/img/favicons/favicon.ico">
<meta name="apple-mobile-web-app-title" content="SIRLIS">
<meta name="application-name" content="SIRLIS">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">


  
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
      <link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin>
    
      <link rel="preconnect" href="https://fonts.googleapis.com" >
      <link rel="dns-prefetch" href="https://fonts.googleapis.com" >
    
      <link rel="preconnect" href="https://cdn.jsdelivr.net" >
      <link rel="dns-prefetch" href="https://cdn.jsdelivr.net" >
    

    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap">
  

  <!-- GA -->
  

  <!-- Bootstrap -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css">

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">

  <link rel="stylesheet" href="/assets/css/style.css">

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.21.0/dist/tocbot.min.css">
  

  
    <!-- Manific Popup -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css">
  

  <!-- JavaScript -->

  
    <!-- Switch the mode between dark and light. -->

<script type="text/javascript">
  class ModeToggle {
    static get MODE_KEY() {
      return 'mode';
    }
    static get MODE_ATTR() {
      return 'data-mode';
    }
    static get DARK_MODE() {
      return 'dark';
    }
    static get LIGHT_MODE() {
      return 'light';
    }
    static get ID() {
      return 'mode-toggle';
    }

    constructor() {
      if (this.hasMode) {
        if (this.isDarkMode) {
          if (!this.isSysDarkPrefer) {
            this.setDark();
          }
        } else {
          if (this.isSysDarkPrefer) {
            this.setLight();
          }
        }
      }

      let self = this;

      /* always follow the system prefers */
      this.sysDarkPrefers.addEventListener('change', () => {
        if (self.hasMode) {
          if (self.isDarkMode) {
            if (!self.isSysDarkPrefer) {
              self.setDark();
            }
          } else {
            if (self.isSysDarkPrefer) {
              self.setLight();
            }
          }

          self.clearMode();
        }

        self.notify();
      });
    } /* constructor() */

    get sysDarkPrefers() {
      return window.matchMedia('(prefers-color-scheme: dark)');
    }

    get isSysDarkPrefer() {
      return this.sysDarkPrefers.matches;
    }

    get isDarkMode() {
      return this.mode === ModeToggle.DARK_MODE;
    }

    get isLightMode() {
      return this.mode === ModeToggle.LIGHT_MODE;
    }

    get hasMode() {
      return this.mode != null;
    }

    get mode() {
      return sessionStorage.getItem(ModeToggle.MODE_KEY);
    }

    /* get the current mode on screen */
    get modeStatus() {
      if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) {
        return ModeToggle.DARK_MODE;
      } else {
        return ModeToggle.LIGHT_MODE;
      }
    }

    setDark() {
      document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE);
      sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE);
    }

    setLight() {
      document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE);
      sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE);
    }

    clearMode() {
      document.documentElement.removeAttribute(ModeToggle.MODE_ATTR);
      sessionStorage.removeItem(ModeToggle.MODE_KEY);
    }

    /* Notify another plugins that the theme mode has changed */
    notify() {
      window.postMessage(
        {
          direction: ModeToggle.ID,
          message: this.modeStatus
        },
        '*'
      );
    }

    flipMode() {
      if (this.hasMode) {
        if (this.isSysDarkPrefer) {
          if (this.isLightMode) {
            this.clearMode();
          } else {
            this.setLight();
          }
        } else {
          if (this.isDarkMode) {
            this.clearMode();
          } else {
            this.setDark();
          }
        }
      } else {
        if (this.isSysDarkPrefer) {
          this.setLight();
        } else {
          this.setDark();
        }
      }

      this.notify();
    } /* flipMode() */
  } /* ModeToggle */

  const modeToggle = new ModeToggle();
</script>

  

  <!-- A placeholder to allow defining custom metadata -->

</head>


  <body>
    <!-- The Side Bar -->

<div id="sidebar" class="d-flex flex-column align-items-end">
  <div class="profile-wrapper">
    <a href="/" id="avatar" class="rounded-circle">
      
        
        <img src="/assets/img/head.jpg" width="112" height="112" alt="avatar" onerror="this.style.display='none'">
      
    </a>

    <div class="site-title">
      <a href="/">SIRLIS</a>
    </div>
    <div class="site-subtitle fst-italic">分享科研和生活的日常</div>
  </div>
  <!-- .profile-wrapper -->

  <ul class="nav flex-column flex-grow-1 w-100 ps-0">
    <!-- home -->
    <li class="nav-item">
      <a href="/" class="nav-link">
        <i class="fa-fw fas fa-home"></i>
        <span>首页</span>
      </a>
    </li>
    <!-- the real tabs -->
    
      <li class="nav-item">
        <a href="/categories/" class="nav-link">
          <i class="fa-fw fas fa-stream"></i>
          

          <span>分类</span>
        </a>
      </li>
      <!-- .nav-item -->
    
      <li class="nav-item">
        <a href="/tags/" class="nav-link">
          <i class="fa-fw fas fa-tags"></i>
          

          <span>标签</span>
        </a>
      </li>
      <!-- .nav-item -->
    
      <li class="nav-item">
        <a href="/archives/" class="nav-link">
          <i class="fa-fw fas fa-archive"></i>
          

          <span>归档</span>
        </a>
      </li>
      <!-- .nav-item -->
    
      <li class="nav-item">
        <a href="/about/" class="nav-link">
          <i class="fa-fw fas fa-info-circle"></i>
          

          <span>关于</span>
        </a>
      </li>
      <!-- .nav-item -->
    
  </ul>
  <!-- ul.nav.flex-column -->

  <div class="sidebar-bottom d-flex flex-wrap  align-items-center w-100">
    
      <button class="mode-toggle btn" aria-label="Switch Mode">
        <i class="fas fa-adjust"></i>
      </button>

      
        <span class="icon-border"></span>
      
    

    
      

      
        <a
          href="https://github.com/sirlis"
          aria-label="github"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-github"></i>
        </a>
      
    
      

      
        <a
          href="https://twitter.com/none"
          aria-label="twitter"
          

          
            target="_blank"
            
          

          

          
            rel="noopener noreferrer"
          
        >
          <i class="fab fa-twitter"></i>
        </a>
      
    
      

      
        <a
          href="javascript:location.href = 'mailto:' + ['lihongjue','buaa.edu.cn'].join('@')"
          aria-label="email"
          

          

          

          
        >
          <i class="fas fa-envelope"></i>
        </a>
      
    
      

      
        <a
          href="/feed.xml"
          aria-label="rss"
          

          

          

          
        >
          <i class="fas fa-rss"></i>
        </a>
      
    
  </div>
  <!-- .sidebar-bottom -->
</div>
<!-- #sidebar -->


    <div id="main-wrapper" class="d-flex justify-content-center">
      <div id="main" class="container px-xxl-5">
        <!-- The Top Bar -->

<div id="topbar-wrapper">
  <div
    id="topbar"
    class="container d-flex align-items-center justify-content-between h-100"
  >
    <span id="breadcrumb">
      

      
        
          
            <span>
              <a href="/">
                首页
              </a>
            </span>

          
        
          
        
          
            
              <span>人工智能（搜索策略）</span>
            

          
        
      
    </span>
    <!-- endof #breadcrumb -->

    <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i>

    <div id="topbar-title">
      文章
    </div>

    <i id="search-trigger" class="fas fa-search fa-fw"></i>
    <span id="search-wrapper" class="align-items-center">
      <i class="fas fa-search fa-fw"></i>
      <input
        class="form-control"
        id="search-input"
        type="search"
        aria-label="search"
        autocomplete="off"
        placeholder="搜索..."
      >
    </span>
    <span id="search-cancel">取消</span>
  </div>
</div>

        











<div class="row">
  <!-- core -->
  <div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pe-xl-4">
    

    <div class="post px-1 px-md-2">
      

      
        
      
        <!-- Refactor the HTML structure -->



<!--
  In order to allow a wide table to scroll horizontally,
  we suround the markdown table with `<div class="table-wrapper">` and `</div>`
-->



<!--
  Fixed kramdown code highlight rendering:
  https://github.com/penibelst/jekyll-compress-html/issues/101
  https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901
-->



<!-- Change the icon of checkbox -->


<!-- images -->



  
  

  <!-- CDN URL -->
  

  <!-- Add image path -->
  

  
    
      
      
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  
    

    
    

    

    
    

    
    
    
    

    
      

      
      
      

      
    
      

      
      
      

      
    

    <!-- take out classes -->
    

    

    

    

    <!-- lazy-load images <https://github.com/aFarkas/lazysizes#readme> -->
    
    

    <!-- add image placeholder -->
    
      
    

    <!-- Bypass the HTML-proofer test -->
    

    
      <!-- make sure the `<img>` is wrapped by `<a>` -->
      

      
        <!-- create the image wrapper -->
        
      
    

    <!-- combine -->
    

  

  



<!-- Add header for code snippets -->



<!-- Create heading anchors -->





  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    

    

  

  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    

    

  

  
  

  
    
    

    
      
        
        
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    
      

      
      

      
      
      

      

    

    

  

  
  

  




<!-- return -->




<h1 data-toc-skip>人工智能（搜索策略）</h1>

<div class="post-meta text-muted">
    <!-- published date -->
    <span>
      发表于
      <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->





<em
  class=""
  data-ts="1758072589"
  data-df="YYYY/MM/DD"
  
    data-bs-toggle="tooltip" data-bs-placement="bottom"
  
>
  2025/09/17
</em>

    </span>

    <!-- lastmod date -->
    
    <span>
      更新于
      <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->





<em
  class=""
  data-ts="1758544076"
  data-df="YYYY/MM/DD"
  
    data-bs-toggle="tooltip" data-bs-placement="bottom"
  
>
  2025/09/22
</em>

    </span>
    

  

  <div class="d-flex justify-content-between">
    <!-- author(s) -->
    <span>
      

      作者

      <em>
      
        <a href="https://github.com/sirlis">sirlis</a>
      
      </em>
    </span>

    <div>
      <!-- read time -->
      <!-- Calculate the post's reading time, and display the word count in tooltip -->



<!-- words per minute -->










<!-- return element -->
<span
  class="readtime"
  data-bs-toggle="tooltip"
  data-bs-placement="bottom"
  title="11282 字"
>
  <em>62 分钟</em>阅读</span>

    </div>

  </div> <!-- .d-flex -->

</div> <!-- .post-meta -->

<div class="post-content">
  <p>搜索算法是人工智能领域的核心基础，为智能系统提供了在复杂问题空间中寻找可行解或最优解的能力。从简单的迷宫寻路到复杂的游戏决策，搜索算法构成了许多人工智能应用的基石。</p>

<p>本文系统性地介绍了人工智能中四大类搜索算法：无信息搜索、有信息搜索、$A^\star$ 搜索和蒙特卡罗树搜索。无信息搜索包括枚举搜索、广度优先搜索和深度优先搜索，它们不利用任何领域知识，通过系统性的空间探索来寻找解。有信息搜索则引入启发式函数来引导搜索方向，显著提高搜索效率，其中贪婪最佳优先搜索和A算法是典型代表。$A^\star$ 算法结合了 Dijkstra 算法的最优性保证和贪婪搜索的高效性，成为路径规划等领域的黄金标准。最后，蒙特卡罗树搜索通过随机模拟和树形搜索的结合，在复杂决策问题中展现出强大能力，特别是在 AlphaGo 等突破性 AI 系统中发挥了关键作用。</p>

<!--more-->

<ul>
  <li><a href="#1-概述">1. 概述</a></li>
  <li><a href="#2-无信息搜索">2. 无信息搜索</a>
    <ul>
      <li><a href="#21-枚举搜索">2.1. 枚举搜索</a></li>
      <li><a href="#22-广度优先搜索">2.2. 广度优先搜索</a>
        <ul>
          <li><a href="#221-搜索原理">2.2.1. 搜索原理</a></li>
          <li><a href="#222-代码实现">2.2.2. 代码实现</a></li>
          <li><a href="#223-搜索特点">2.2.3. 搜索特点</a></li>
        </ul>
      </li>
      <li><a href="#23-深度优先搜索">2.3. 深度优先搜索</a>
        <ul>
          <li><a href="#231-搜索原理">2.3.1. 搜索原理</a></li>
          <li><a href="#232-代码实现">2.3.2. 代码实现</a></li>
          <li><a href="#233-搜索特点">2.3.3. 搜索特点</a></li>
        </ul>
      </li>
      <li><a href="#24-小结">2.4. 小结</a></li>
    </ul>
  </li>
  <li><a href="#3-有信息搜索">3. 有信息搜索</a>
    <ul>
      <li><a href="#31-启发信息与启发函数">3.1. 启发信息与启发函数</a></li>
      <li><a href="#32-贪婪最佳优先搜索">3.2. 贪婪最佳优先搜索</a>
        <ul>
          <li><a href="#321-搜索原理">3.2.1. 搜索原理</a></li>
          <li><a href="#322-代码实现">3.2.2. 代码实现</a></li>
          <li><a href="#323-搜索特点">3.2.3. 搜索特点</a></li>
        </ul>
      </li>
      <li><a href="#33-a-搜索">3.3. A* 搜索</a>
        <ul>
          <li><a href="#331-dijkstra-算法">3.3.1. Dijkstra 算法</a></li>
          <li><a href="#332-a-算法">3.3.2. A* 算法</a></li>
          <li><a href="#333-搜索流程">3.3.3. 搜索流程</a></li>
          <li><a href="#334-实例">3.3.4. 实例</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#4-蒙特卡罗树搜索">4. 蒙特卡罗树搜索</a>
    <ul>
      <li><a href="#41-极大极小minimax搜索算法">4.1. 极大极小（minimax）搜索算法</a></li>
      <li><a href="#42-蒙特卡罗树搜索">4.2. 蒙特卡罗树搜索</a>
        <ul>
          <li><a href="#421-蒙特卡罗方法">4.2.1. 蒙特卡罗方法</a></li>
          <li><a href="#422-蒙特卡罗树搜索">4.2.2. 蒙特卡罗树搜索</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="1-概述"><span class="me-2">1. 概述</span><a href="#1-概述" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<p>搜索是通过执行行为序列达到目标的工作，是由初始状态达到目标状态的求解过程。</p>

<p>在前面的知识表示和推理中，我们提到了正向推理和反向推理两种方法，并且提及 “不管是何种推理规则，在执行过程中都会得到不只一条规则被满足，此时推理机需要根据某种策略（如优先级、特异性、新近度等）选择一条规则来执行。” 这里的选择就是采取一种搜索策略。</p>

<p>根据搜索过程的不同，可以分几种搜索策略：</p>

<ul>
  <li>无信息搜索策略
    <ul>
      <li>广度优先搜索（Breadth-first search, BFS）</li>
      <li>深度优先搜索（Depth-first search, DFS）</li>
    </ul>
  </li>
  <li>有信息搜索策略
    <ul>
      <li>贪婪最佳优先搜索</li>
      <li>$A^\star$ 搜索</li>
    </ul>
  </li>
</ul>

<h2 id="2-无信息搜索"><span class="me-2">2. 无信息搜索</span><a href="#2-无信息搜索" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<p>无信息搜索又被称为盲目搜索，是预先规定好控制策略进行搜索，在搜索过程中获取的中间信息不影响或改变控制策略，由于搜索总是按预先规定的路线进行，没有考虑到问题本身的特性，所以这种搜索具有盲目性，效率不高，不便于复杂问题的求解。</p>

<p>尽管盲目搜索的性能不如启发式搜索，但由于启发式搜索需要抽取与问题本身有关的特征信息，而这种特征信息的抽取往往又比较困难，因此盲目搜索仍不失为一种有用的搜索策略。</p>

<h3 id="21-枚举搜索"><span class="me-2">2.1. 枚举搜索</span><a href="#21-枚举搜索" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>枚举算法是我们在日常中使用到的最多的一个算法，它的核心思想就是：枚举所有的可能。枚举法的本质就是从所有候选答案中去搜索正确的解，使用该算法需要满足两个条件：</p>

<ul>
  <li>可预先确定候选答案的数量；</li>
  <li>候选答案的范围在求解之前必须有一个确定的集合。</li>
</ul>

<p>枚举算法简单粗暴，他暴力的枚举所有可能，尽可能地尝试所有的方法。虽然枚举算法非常暴力，而且速度可能很慢，但可以优先考虑，因为枚举法实现最简单，并且得到的结果总是正确的。</p>

<p><strong>举例1</strong>：人生来就有三个生理周期，分别为体力、感情和智力周期，它们的周期长度为23天，28天，33天。每一个周期中有一天是高峰。已知三个生理周期高峰后分别经过了10天，12天，5天。<strong>问</strong>：下一次三个高峰落在同一天是第几天？</p>

<p>分析：</p>
<ul>
  <li>可预先确定候选答案的数量；(1个)</li>
  <li>候选答案的范围在求解之前必须有一个确定的集合。（最多遍历 $23\times 28\times 33$ 次）<font color="red">为什么？</font></li>
</ul>

<blockquote>
  <p>假设 $d$ 天后，三个高峰落在同一天。问题转化为如下同余方程：</p>

\[\begin{aligned}
d &amp;\equiv 10 \pmod{23} \\
d &amp;\equiv 16 \pmod{28} \\
d &amp;\equiv 28 \pmod{33}
\end{aligned}\]

  <p>其中 $a\equiv b \pmod c$ 的意思是 $a \mod c = b \mod c$，实际上上式可用中国剩余定理直接求解。无须枚举。</p>

  <p>由于 $23$、$28$、$33$ 两两互质，根据中国剩余定理，同余方程组在模 $23\times 28\times 33 = 21252$ 下存在唯一解。</p>
</blockquote>

<p>假设下一次人生巅峰时，三个高峰同为当天 $d$，经过 $n_1$ 个体力周期，$n_2$ 个感情周期，$n_3$ 个智力周期，有</p>

\[d = 10+n_1\times 23 = 12+n_2\times 28 = 5+n_3\times 33\]

<p>隐含要素： $n_1$，$n_2$，$n_3$ 都是整数！</p>

<p>则枚举搜索代码如下：</p>

<div class="language-c++ highlighter-rouge"><div class="code-header">
        <span data-label-text="C++"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="o">&lt;</span><span class="mi">23</span><span class="err">×</span><span class="mi">28</span><span class="err">×</span><span class="mi">33</span><span class="p">,</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span><span class="o">%</span><span class="mi">23</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">t</span><span class="o">-</span><span class="mi">12</span><span class="p">)</span><span class="o">%</span><span class="mi">28</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">t</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span><span class="o">%</span><span class="mi">33</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p><strong>举例2</strong>：有一个 $n\times m$ 方格的棋盘，问：其方格包含多少正方形、长方形（不包含正方形） ？</p>

<p>分析：</p>

<ul>
  <li>可预先确定候选答案的数量；(有限个)</li>
  <li>候选答案的范围在求解之前必须有一个确定的集合。（很明显）</li>
  <li>矩形包含长方形和正方形，首先算出棋盘有多少个矩形</li>
</ul>

<p>枚举边：</p>

<ul>
  <li>一个矩形两个边，两点构成一个边</li>
  <li>横向所有可能的边长 $((n+1)\times n)/2$</li>
  <li>纵向所有可能的边长 $((m+1)\times m)/2$</li>
  <li>棋盘包含的所有的矩形个数为两式相乘。</li>
</ul>

<p>正方形个数：</p>

<ul>
  <li>正方形最大边长一定是m和n中的较小的那一个。</li>
  <li>假设正方形边长为 $i$，枚举 $i=1 \to i=\min(m,n)$</li>
  <li>$i=1$ 时，正方形个数为 $m\times n$</li>
  <li>$i=2$ 时，正方形个数为 $(m-1)\times (n-1)$</li>
  <li>…</li>
</ul>

<p>代码如下：</p>

<div class="language-c++ highlighter-rouge"><div class="code-header">
        <span data-label-text="C++"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="n">sum</span> <span class="o">=</span> <span class="p">(((</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(((</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">m</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">square</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">x</span><span class="o">--</span><span class="p">;</span>
    <span class="n">y</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">rec</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">-</span> <span class="n">square</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></div></div>

<h3 id="22-广度优先搜索"><span class="me-2">2.2. 广度优先搜索</span><a href="#22-广度优先搜索" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<h4 id="221-搜索原理"><span class="me-2">2.2.1. 搜索原理</span><a href="#221-搜索原理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<p>广度优先搜索（Breadth-First Search, BFS）是一种用于遍历或搜索树或图数据结构的算法。它从根节点（或任意指定节点）开始，首先访问所有相邻节点，然后再依次访问这些相邻节点的未访问过的相邻节点。这个过程会逐层地向外扩展，因此它也被称为 “层次遍历”。</p>

<blockquote>
  <p>“先被访问的节点，其邻接点也先被访问”，这是一种先进先出（FIFO） 的思想。因此，BFS算法天然地需要借助队列（Queue） 这种数据结构来实现。</p>

  <p><a href="/assets/img/postsimg/20250917/bfs-queue.jpg" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/bfs-queue.jpg" alt="queue" class="lazyload" data-proofer-ignore></a></p>
</blockquote>

<p>假设如下有向图，广度优先遍历过程如下所述：</p>

<p><a href="/assets/img/postsimg/20250917/bfs-0.jpg" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/bfs-0.jpg" alt="bfs-0" class="lazyload" data-proofer-ignore></a></p>

<ol>
  <li>
    <p>初始化所有节点的访问状态为未访问：<code class="language-plaintext highlighter-rouge">visited[i] = false, i = 1, 2, 3, 4, 5, 6</code></p>
  </li>
  <li>
    <p>创建一个空队列 $Q$，从任意节点出发（比如（1）），将节点（1）入队</p>
  </li>
</ol>

<p><a href="/assets/img/postsimg/20250917/bfs-1.jpg" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/bfs-1.jpg" alt="bfs-1" class="lazyload" data-proofer-ignore></a></p>

<ol>
  <li>当队列 $Q$ 非空时，从队列中取出队首节点（1），并且标志 <code class="language-plaintext highlighter-rouge">visited[1] = true</code>。将取出节点的未被访问的邻接点（2、3）入队</li>
</ol>

<p><a href="/assets/img/postsimg/20250917/bfs-2.jpg" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/bfs-2.jpg" alt="bfs-2" class="lazyload" data-proofer-ignore></a></p>

<ol>
  <li>当队列 $Q$ 非空时，从队列中取出队首节点（2），并且标志 <code class="language-plaintext highlighter-rouge">visited[2] = true</code>。将取出节点的未被访问的邻接点（4）入队</li>
</ol>

<p><a href="/assets/img/postsimg/20250917/bfs-3.jpg" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/bfs-3.jpg" alt="bfs-3" class="lazyload" data-proofer-ignore></a></p>

<ol>
  <li>当队列 $Q$ 非空时，从队列中取出队首节点（3），并且标志 <code class="language-plaintext highlighter-rouge">visited[3] = true</code>。将取出节点的未被访问的邻接点（5）入队</li>
</ol>

<p><a href="/assets/img/postsimg/20250917/bfs-4.jpg" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/bfs-4.jpg" alt="bfs-4" class="lazyload" data-proofer-ignore></a></p>

<ol>
  <li>当队列 $Q$ 非空时，从队列中取出队首节点（4），并且标志 <code class="language-plaintext highlighter-rouge">visited[4] = true</code>。将取出节点的未被访问的邻接点（6）入队</li>
</ol>

<p><a href="/assets/img/postsimg/20250917/bfs-5.jpg" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/bfs-5.jpg" alt="bfs-5" class="lazyload" data-proofer-ignore></a></p>

<ol>
  <li>当队列 $Q$ 非空时，从队列中取出队首节点（5），并且标志 <code class="language-plaintext highlighter-rouge">visited[5] = true</code>。取出节点的邻居节点均被访问。<code class="language-plaintext highlighter-rouge">Q=[6]</code></li>
  <li>当队列 $Q$ 非空时，从队列中取出队首节点（6），并且标志 <code class="language-plaintext highlighter-rouge">visited[6] = true</code>。取出节点的邻居节点均被访问。<code class="language-plaintext highlighter-rouge">Q=[]</code></li>
  <li>队列 $Q$ 为空，算法结束。广度优先遍历序列为 <code class="language-plaintext highlighter-rouge">[1 2 3 4 5 6]</code>。</li>
</ol>

<p>广度优先遍历经过的节点及边形成的树被称为“广度优先生成树”，如下图所示。若广度优先遍历非连通图，则每个连通分量都会产生一棵广度优先生成树，所有广度优先生成树构成广度优先生成森林。</p>

<p><a href="/assets/img/postsimg/20250917/bfs-6.jpg" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/bfs-6.jpg" alt="bfs-6" class="lazyload" data-proofer-ignore></a></p>

<h4 id="222-代码实现"><span class="me-2">2.2.2. 代码实现</span><a href="#222-代码实现" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<p>基于邻接矩阵的广度优先搜索代码如下：</p>

<div class="language-c++ highlighter-rouge"><div class="code-header">
        <span data-label-text="C++"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">BFS_AM</span><span class="p">(</span><span class="kt">int</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>    <span class="c1">// 基于邻接矩阵的广度优先遍历</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Q</span><span class="p">;</span>      <span class="c1">// 创建一个普通队列（先进先出），存储 int 类型的数据</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">s</span><span class="o">&lt;&lt;</span><span class="s">"</span><span class="se">\t</span><span class="s">"</span><span class="p">;</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>  <span class="c1">// 标记为已访问</span>
    <span class="n">Q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>    <span class="c1">// 将 s 入队</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">Q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>  <span class="c1">// 若队列不为空</span>
        <span class="kt">int</span> <span class="n">u</span><span class="o">=</span><span class="n">Q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>  <span class="c1">// 取出队头元素</span>
        <span class="n">Q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>      <span class="c1">// 队头元素出队</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">v</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">v</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 依次检查所有节点</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>  <span class="c1">// u、v 邻接而且 v 未被访问</span>
                <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">v</span><span class="o">&lt;&lt;</span><span class="s">"</span><span class="se">\t</span><span class="s">"</span><span class="p">;</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
                <span class="n">Q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>遍历每个节点的邻接点的时间复杂度为 $O(n)$，共 $n$ 个节点，总时间复杂度为 $O(n^2)$。使用了一个辅助队列，每个节点都只入队一次，空间复杂度为 $O(n)$。</p>

<h4 id="223-搜索特点"><span class="me-2">2.2.3. 搜索特点</span><a href="#223-搜索特点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<p>广度优先搜索能找到从起点到目标节点的最短路径，但它的最优性仅限于路径长度，而非其他优化目标。具体来说，当抵达终点时，从终点开始逐步回溯节点的父节点，最终抵达起点，得到的路径就是最短路径。</p>

<details>
  <summary>
<font color="blue">思考：广度优先搜索结束后如何回溯得到最优路径？</font>

<a href="/assets/img/postsimg/20250917/dfs-notoptimal.png" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/dfs-notoptimal.png" alt="" class="lazyload" data-proofer-ignore></a>

</summary>

  <p><a href="/assets/img/postsimg/20250917/bfs-optimal.png" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/bfs-optimal.png" alt="" class="lazyload" data-proofer-ignore></a></p>

  <font color="blue">图中，从上至下是广度优先搜索的搜索过程，将搜索点入队，然后逐个取出队头的节点，并检查该节点的邻居节点，依次入队。当找到终点后，从终点回溯，找到它对应的父节点，并追溯到父节点入队时它的父节点，依次回溯直到起点。最终得到的路径就是最短路径。</font>

</details>

<p>下图展示了一个使用广度优先搜索探索从迷宫起点到迷宫终点最短路径的例子：</p>

<p><a href="/assets/img/postsimg/20250917/bfs-migong.gif" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/bfs-migong.gif" alt="" class="lazyload" data-proofer-ignore></a></p>

<p>可以看出，迷宫结束时，得到的路径确实是最短路径。</p>

<p><a href="/assets/img/postsimg/20250917/bfs-migong-result.jpg" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/bfs-migong-result.jpg" alt="" class="lazyload" data-proofer-ignore></a></p>

<h3 id="23-深度优先搜索"><span class="me-2">2.3. 深度优先搜索</span><a href="#23-深度优先搜索" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<h4 id="231-搜索原理"><span class="me-2">2.3.1. 搜索原理</span><a href="#231-搜索原理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<p>深度优先搜索（Depth-First Search）是一种用于遍历或搜索树或图的算法。这个算法会尽可能深地搜索一个分支，直到它到达尽头，然后回溯（Backtrack）到上一个分叉点，再选择另一条分支继续深入搜索。深度优先搜索使用递归或者栈（Stack）数据结构来实现上述特性。</p>

<blockquote>
  <p>栈是一种后进先出(LIFO)的容器，如下图</p>

  <p><a href="/assets/img/postsimg/20250917/dfs-stack.jpg" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/dfs-stack.jpg" alt="" class="lazyload" data-proofer-ignore></a></p>
</blockquote>

<h4 id="232-代码实现"><span class="me-2">2.3.2. 代码实现</span><a href="#232-代码实现" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<p>递归写法简洁，如下：</p>

<div class="language-c++ highlighter-rouge"><div class="code-header">
        <span data-label-text="C++"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">dfsRecursive</span><span class="p">(</span><span class="kt">int</span> <span class="n">node</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">graph</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&amp;</span> <span class="n">visited</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 1. 标记当前节点为已访问</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="c1">// 2. 处理当前节点（例如打印）</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Visiting node: "</span> <span class="o">&lt;&lt;</span> <span class="n">node</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="c1">// 3. 递归地访问所有未访问的邻居</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">neighbor</span> <span class="o">:</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">dfsRecursive</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">visited</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 主函数中调用示例</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">numNodes</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">}</span> <span class="p">};</span> <span class="c1">// 邻接表</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">(</span><span class="n">numNodes</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span> <span class="c1">// 访问标记数组</span>

    <span class="c1">// 从节点0开始DFS遍历</span>
    <span class="n">dfsRecursive</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">visited</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<p>而迭代的写法避免了递归深度过大的问题。因为递归使用系统的“调用栈”（Call Stack），而迭代使用自己申请的内存“栈”（Stack Data Structure）。系统调用栈的大小限制通常远小于我们自己在堆（Heap）上申请的栈数据结构的大小。因此，当递归深度非常大时，系统调用栈会先被耗尽，导致栈溢出（Stack Overflow）；而迭代法使用的堆内存空间通常大得多，更能处理深度大的问题。</p>

<p>迭代写法如下：</p>

<div class="language-c++ highlighter-rouge"><div class="code-header">
        <span data-label-text="C++"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">dfsIterative</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">graph</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&amp;</span> <span class="n">visited</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">currentNode</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Visiting node: "</span> <span class="o">&lt;&lt;</span> <span class="n">currentNode</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

        <span class="c1">// 注意：这里为了与递归顺序一致，从最后一个邻居开始压栈</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">currentNode</span><span class="p">].</span><span class="n">rbegin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">graph</span><span class="p">[</span><span class="n">currentNode</span><span class="p">].</span><span class="n">rend</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">neighbor</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">neighbor</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>

<ul>
  <li>
    <p>时间复杂度：O(V + E)</p>

    <ul>
      <li>
        <p>V 是顶点（Vertex）的数量。</p>
      </li>
      <li>
        <p>E 是边（Edge）的数量。</p>
      </li>
      <li>
        <p>原因：每个节点被访问一次（入栈/出栈一次），每条边也被检查一次（在遍历邻居时）。</p>
      </li>
    </ul>
  </li>
  <li>
    <p>空间复杂度：O(V)</p>

    <ul>
      <li>
        <p>最坏情况下，栈需要存储整条路径上的所有节点。例如，在一条链状的图中，栈可能同时存储所有V个节点。</p>
      </li>
      <li>
        <p>递归实现还需考虑系统调用栈的开销。</p>
      </li>
    </ul>
  </li>
</ul>

<h4 id="233-搜索特点"><span class="me-2">2.3.3. 搜索特点</span><a href="#233-搜索特点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<details>
  <summary>
<font color="blue">尝试在下图中思考深度优先搜索的过程和结果（注意保持与递归顺序一致）</font>

<a href="/assets/img/postsimg/20250917/dfs-notoptimal.png" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/dfs-notoptimal.png" alt="" class="lazyload" data-proofer-ignore></a>

</summary>

  <p><a href="/assets/img/postsimg/20250917/dfs-notoptimal2.png" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/dfs-notoptimal2.png" alt="" class="lazyload" data-proofer-ignore></a></p>

  <p><a href="/assets/img/postsimg/20250917/dfs-notoptimal3.png" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/dfs-notoptimal3.png" alt="" class="lazyload" data-proofer-ignore></a></p>

  <font color="blue">可以看出，深度优先搜索「**<font color="red">不能保证</font>**」找到最短路径！</font>

</details>

<p>对于同样的迷宫例子，使用深度优先搜索算法，得到路径如下：</p>

<p><a href="/assets/img/postsimg/20250917/dfs-migong.gif" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/dfs-migong.gif" alt="" class="lazyload" data-proofer-ignore></a></p>

<p>但是注意到，深度优先搜索的搜索速度<strong>更快</strong>，但找到的并不是最短路径。</p>

<p><a href="/assets/img/postsimg/20250917/dfs-migong-result.jpg" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/dfs-migong-result.jpg" alt="" class="lazyload" data-proofer-ignore></a></p>

<h3 id="24-小结"><span class="me-2">2.4. 小结</span><a href="#24-小结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>深度优先搜索 能够快速地找到一条路径，是一种以时间换空间的方法，不能保证搜索到的路径是最优的。而 广度优先搜索 在搜索时呈波状推进形式，一路稳扎稳打，它是一种以时间换空间的方法，能够保证搜索到的路径是最优的。</p>

<h2 id="3-有信息搜索"><span class="me-2">3. 有信息搜索</span><a href="#3-有信息搜索" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<p>广度优先搜索 和 深度优先搜索 的区别主要在于节点的弹出策略，根据弹出策略的区别，分别使用了队列和栈两种数据结构，而栈和队列作为两种相当基本的容器，只将节点进入容器的顺序作为弹出节点的依据，并未考虑目标位置等因素，这就使搜索过程变得漫无目的，导致效率低下。</p>

<p>启发式搜索（Heuristic Search）可以克服上述搜索效率低下的问题。启发式搜索是利用与问题相关的启发信息来预测目标节点的存在方向，并按该方向进行搜索，这样可以缩小搜索范围、提高搜索效率。</p>

<h3 id="31-启发信息与启发函数"><span class="me-2">3.1. 启发信息与启发函数</span><a href="#31-启发信息与启发函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<ul>
  <li><strong>启发信息</strong>：与具体问题的求解过程有关的、并可指导搜索过程往最优希望方向前进的控制信息。启发信息主要包括以下三种信息：
    <ul>
      <li>能有效帮助系统确定扩展节点的信息；</li>
      <li>能有效帮助决定哪些后继节点应该被生成的信息；</li>
      <li>能决定在扩展一个节点时哪些节点应从搜索树中删除的信息。</li>
    </ul>
    <details>
      <summary>
<font color="blue"> - 思考：路径规划问题中有什么启发信息可以利用？</font>

</summary>

      <font color="blue">“两点之间的直线距离”就是一种启发信息。因为它告诉我们，当前点离目标点至少还有多远，这通常比“已经走过的路径长度”更能指导我们前进的方向。但 需要注意，诸如走迷宫等寻路问题中，直线路径可能与最短路径呈现冲突关系。</font>

    </details>

    <details>
      <summary>
<font color="blue"> - 思考：下棋游戏中有什么启发信息可以利用？</font>

</summary>

      <font color="blue">“棋盘上我方棋子数量减去对方棋子数量”或“控制中心区域的程度”就是一种启发信息。它能快速评估当前棋局对我方是否有利。</font>

    </details>
  </li>
  <li><strong>启发函数</strong>：又称为估价函数，用于评估节点的重要性，是启发信息的数学化形式。它是一个具体的函数，用于量化评估从搜索树中的当前状态（或节点）到目标状态的 “期望距离” 或 “期望代价”。它通常记为 $h(n)$，其中 $n$ 代表当前节点。
    <ul>
      <li>在搜索过程中，启发函数为每个待扩展的节点计算一个启发值，算法优先选择 “最有希望” 的节点（即 $h(n)$ 值最小的节点）进行扩展。</li>
      <li>既然 $h(n)$ 是一个估计值，那么它可能估计不准。启发函数不唯一，且的设计好坏直接影响搜索算法的优劣，最好的启发函数应与实际耗散相等。</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>“有信息搜索” 和 “启发式搜索” 的区别在于范畴的广度不同。所有的启发式搜索都是有信息搜索，但并非所有的有信息搜索都一定是启发式搜索。</p>

  <p>有信息搜索的评估函数 $f(n)$ 可以是任何形式，而启发式搜索的 $f(n)$ 特指包含启发函数 $h(n)$ 的形式。</p>
</blockquote>

<h3 id="32-贪婪最佳优先搜索"><span class="me-2">3.2. 贪婪最佳优先搜索</span><a href="#32-贪婪最佳优先搜索" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<h4 id="321-搜索原理"><span class="me-2">3.2.1. 搜索原理</span><a href="#321-搜索原理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<p>如果我们设置评估函数就为启发函数：</p>

\[f(n) = h(n)\]

<p>其中 $h(n)$ 是从当前节点到目标节点的估计代价，这种策略被称为「<strong>贪婪最佳优先算法</strong>」（Greedy Best First Search, GBFS）。</p>

<p>对于当前节点 $n$ 和目标节点 $g$ ，常用的启发函数为欧氏距离和曼哈顿距离：</p>

\[h(n) = \sqrt{(x_n - x_g)^2 + (y_n - y_g)^2}\]

\[h(n) = |x_n - x_g| + |y_n - y_g|\]

<h4 id="322-代码实现"><span class="me-2">3.2.2. 代码实现</span><a href="#322-代码实现" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<p>GBFS 的算法流程和 BFS、DFS 并没有本质的不同，区别仍然在于采用的数据结构，GBFS 使用的是优先队列（Priority Queue），普通队列是一种先进先出的数据结构，而在优先队列中元素被赋予了优先级，最高优先级元素优先删除，也就是 first in, largest out 。</p>

<div class="language-c++ highlighter-rouge"><div class="code-header">
        <span data-label-text="C++"><i class="fas fa-code fa-fw small"></i></span>
      <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
</pre></td><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unordered_set&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">// 定义图结构（邻接表）</span>
<span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="sc">'A'</span><span class="p">,</span> <span class="p">{</span> <span class="p">{</span><span class="sc">'B'</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="sc">'C'</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span> <span class="p">}</span> <span class="p">},</span>
    <span class="p">{</span><span class="sc">'B'</span><span class="p">,</span> <span class="p">{</span> <span class="p">{</span><span class="sc">'D'</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span> <span class="p">}</span> <span class="p">},</span>
    <span class="p">{</span><span class="sc">'C'</span><span class="p">,</span> <span class="p">{</span> <span class="p">{</span><span class="sc">'E'</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span> <span class="p">}</span> <span class="p">},</span>
    <span class="p">{</span><span class="sc">'D'</span><span class="p">,</span> <span class="p">{</span> <span class="p">{</span><span class="sc">'F'</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span> <span class="p">}</span> <span class="p">},</span>
    <span class="p">{</span><span class="sc">'E'</span><span class="p">,</span> <span class="p">{</span> <span class="p">{</span><span class="sc">'F'</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span> <span class="p">}</span> <span class="p">},</span>
    <span class="p">{</span><span class="sc">'F'</span><span class="p">,</span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 启发函数（每个节点到目标节点E的估计距离）</span>
<span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">heuristic</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="sc">'A'</span><span class="p">,</span> <span class="mi">8</span><span class="p">},</span> <span class="p">{</span><span class="sc">'B'</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="sc">'C'</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span>
    <span class="p">{</span><span class="sc">'D'</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="sc">'E'</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="sc">'F'</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
<span class="p">};</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">greedyBestFirstSearch</span><span class="p">(</span><span class="kt">char</span> <span class="n">start</span><span class="p">,</span> <span class="kt">char</span> <span class="n">goal</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 优先队列，按启发值h(n)排序（最小堆）</span>
    <span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="o">&gt;&gt;&gt;</span> <span class="n">frontier</span><span class="p">;</span>
    <span class="n">frontier</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="n">heuristic</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">start</span><span class="p">});</span>
    
    <span class="c1">// 记录节点的父节点（用于重建路径）</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">cameFrom</span><span class="p">;</span>
    <span class="n">cameFrom</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span> <span class="c1">// 起始节点的父节点为空</span>
    
    <span class="c1">// 记录已访问的节点</span>
    <span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">;</span>
    <span class="n">visited</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">frontier</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// 获取当前h(n)最小的节点</span>
        <span class="k">auto</span> <span class="p">[</span><span class="n">current_h</span><span class="p">,</span> <span class="n">current</span><span class="p">]</span> <span class="o">=</span> <span class="n">frontier</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        <span class="n">frontier</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"扩展节点: "</span> <span class="o">&lt;&lt;</span> <span class="n">current</span> <span class="o">&lt;&lt;</span> <span class="s">" (h="</span> <span class="o">&lt;&lt;</span> <span class="n">current_h</span> <span class="o">&lt;&lt;</span> <span class="s">")"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        
        <span class="c1">// 如果找到目标节点</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">==</span> <span class="n">goal</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="c1">// 遍历所有邻居</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">cost</span><span class="p">]</span> <span class="o">:</span> <span class="n">graph</span><span class="p">[</span><span class="n">current</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span> <span class="o">==</span> <span class="n">visited</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">neighbor_h</span> <span class="o">=</span> <span class="n">heuristic</span><span class="p">[</span><span class="n">neighbor</span><span class="p">];</span>
                <span class="n">frontier</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="n">neighbor_h</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">});</span>
                <span class="n">cameFrom</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
                <span class="n">visited</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">neighbor</span><span class="p">);</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"  添加邻居: "</span> <span class="o">&lt;&lt;</span> <span class="n">neighbor</span> <span class="o">&lt;&lt;</span> <span class="s">" (h="</span> <span class="o">&lt;&lt;</span> <span class="n">neighbor_h</span> <span class="o">&lt;&lt;</span> <span class="s">")"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// 重建路径</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cameFrom</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">goal</span><span class="p">)</span> <span class="o">==</span> <span class="n">cameFrom</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{};</span> <span class="c1">// 未找到路径</span>
    <span class="p">}</span>
    
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">current</span> <span class="o">=</span> <span class="n">goal</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">current</span><span class="p">);</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">cameFrom</span><span class="p">[</span><span class="n">current</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">reverse</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">path</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    
    <span class="k">return</span> <span class="n">path</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"=== 贪婪最佳优先搜索 (GBFS) ==="</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"从 A 到 E 的搜索过程:"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"=============================="</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">path</span> <span class="o">=</span> <span class="n">greedyBestFirstSearch</span><span class="p">(</span><span class="sc">'A'</span><span class="p">,</span> <span class="sc">'E'</span><span class="p">);</span>
    
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"=============================="</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"找到路径: "</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">path</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">path</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" -&gt; "</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"未找到路径!"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></div></div>
<h4 id="323-搜索特点"><span class="me-2">3.2.3. 搜索特点</span><a href="#323-搜索特点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<p>GBFS 是极其 “目光短浅” 或 “贪婪” 的。它的策略非常简单：“哪个节点看起来离目标最近，我就下一步去哪”。它只关心未来，不关心过去。</p>

<p>将GBFS应用在二维地图路径规划中，如下图，可以看到它的指向性或者说目的非常明显，从起点直扑终点。</p>

<p><a href="/assets/img/postsimg/20250917/gbfs-1.webp" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/gbfs-1.webp" alt="" class="lazyload" data-proofer-ignore></a></p>

<p>但是在实际的地图中，常常会有很多障碍物，它就很容易<strong>陷入局部最优的陷阱</strong>。下图的地图中有一个专门设置的局部最优陷阱，很显然GBFS虽然搜索速度够快，但是找不到最优路径。</p>

<p><a href="/assets/img/postsimg/20250917/gbfs-2.webp" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/gbfs-2.webp" alt="" class="lazyload" data-proofer-ignore></a></p>

<p>将其应用到复杂二维地图路径规划中，效果如下：</p>

<p><a href="/assets/img/postsimg/20250917/gbfs-3.gif" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/gbfs-3.gif" alt="" class="lazyload" data-proofer-ignore></a></p>

<h3 id="33-a-搜索"><span class="me-2">3.3. A* 搜索</span><a href="#33-a-搜索" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>为了解决贪婪最佳优先搜索容易陷入局部最优的陷阱，A* 搜索引入了<strong>路径代价</strong> $g(n)$ ，对应的评估函数设计如下所示：</p>

\[f(n) = g(n) + h(n)\]

<p>其中 ，$g(n)$ 是从初始节点到当前节点已经获知的实际代价，$h(n)$ 是从当前节点到目标节点的估计代价。</p>

<h4 id="331-dijkstra-算法"><span class="me-2">3.3.1. Dijkstra 算法</span><a href="#331-dijkstra-算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<p>从初始节点到当前节点已经获知的实际代价 $g(n)$ 如何计算呢？</p>

<p>1959 年 Edsger W. Dijkstra（艾兹格·迪杰斯特拉）提出了著名的 Dijkstra 算法，是一种求解有权图中单个源点到所有其它节点的最短路径的算法。当被用于计算从源点到其它所有节点的最短路径时，正好能回答我们的上述问题。</p>

<blockquote>
  <ul>
    <li>
      <p>从某顶点出发，沿图的边到达另一顶点所经过的路径中，各边上权值之和最小的一条路径叫做最短路径。</p>
    </li>
    <li>
      <p>实际上，Dijkstra 本身就是单源最短路径算法，它运行完以后天然就得到了所有节点的 $g(n)$；$A^\star$ 只是在 Dijkstra 的骨架上再叠一个 $h(n)$ 来引导搜索方向。</p>
    </li>
    <li>
      <p>算法发展上，先有 Dijkstra（1959），后有 $A^\star$ （1968 由 Hart 等人提出）对 Dijkstra 做 “启发式加速”。所以有写教材上会先介绍 Dijkstra 算法，再介绍 $A^\star$ 算法。</p>
    </li>
  </ul>
</blockquote>

<p>Dijkstra 算法的前提条件为：<strong>图必须有非负权重</strong>。</p>

<p>假设有如下图，想找到从 $A$ 到 $D$ 的最短路径。</p>

<pre><code class="language-mermaid">graph LR;
A -- 6 --&gt; B;
A -- 1 --&gt; C;
C -- 2  --&gt; B;
C -- 3 --&gt; D;
B -- 5 --&gt; D;
</code></pre>

<p>注意：Dijkstra算法使用优先队列（最小堆），总是先处理当前距离最小的节点，而不是按照添加顺序。因此算法处理过程如下表所示：</p>

<div class="table-wrapper"><table>
  <thead>
    <tr>
      <th>步骤</th>
      <th>当前节点</th>
      <th>距离表: A B C D</th>
      <th>操作说明</th>
      <th>优先队列内容 (距离,节点)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>初始化</strong></td>
      <td>-</td>
      <td>[0, $\infty$, $\infty$, $\infty$]</td>
      <td>起点A距离为0，其他为无穷大</td>
      <td>[(0, A)]</td>
    </tr>
    <tr>
      <td><strong>1</strong></td>
      <td><strong>A</strong></td>
      <td>[0, 6, 1, $\infty$]</td>
      <td>更新B(0+6=6)、C(0+1=1)</td>
      <td>[(1, C), (6, B)]</td>
    </tr>
    <tr>
      <td><strong>2</strong></td>
      <td><strong>C</strong></td>
      <td>[0, 3, 1, 4]</td>
      <td>经C到B:1+2=3＜6，更新B；到D:1+3=4</td>
      <td>[(3, B), (4, D)]</td>
    </tr>
    <tr>
      <td><strong>3</strong></td>
      <td><strong>B</strong></td>
      <td>[0, 3, 1, 4]</td>
      <td>经B到D:3+5=8＞4，不更新D</td>
      <td>[(4, D)]</td>
    </tr>
    <tr>
      <td><strong>4</strong></td>
      <td><strong>D</strong></td>
      <td>[0, 3, 1, 4]</td>
      <td>找到目标节点，算法结束</td>
      <td>[]</td>
    </tr>
  </tbody>
</table></div>

<p>数学上可以证明：当所有边权非负时，当前距离最小的节点的距离值就是最终的最短距离。这是 Dijkstra 算法使用贪心选择扩展队列的关键。</p>

<details>
  <summary>
<font color="blue">尝试：使用 Dijkstra 算法计算起点 a 到终点 i 的最短路径。</font>

<a href="/assets/img/postsimg/20250917/dijkstra-1.png" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/dijkstra-1.png" alt="" class="lazyload" data-proofer-ignore></a>

</summary>

  <p><a href="/assets/img/postsimg/20250917/dijkstra-2.png" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/dijkstra-2.png" alt="" class="lazyload" data-proofer-ignore></a></p>

  <p><a href="/assets/img/postsimg/20250917/dijkstra-3.png" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/dijkstra-3.png" alt="" class="lazyload" data-proofer-ignore></a></p>

  <font color="blue">此时再回顾并对比之前同一张图上的广度优先搜索和深度优先搜索结果，可以发现二者仅能处理无权图。</font>

</details>

<p>使用 Dijkstra 搜索算法走迷宫，由于迷宫并没有设置移动代价，所以其结果与广度优先搜索效果结果一致。</p>

<p><a href="/assets/img/postsimg/20250917/dijkstra-4.gif" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/dijkstra-4.gif" alt="" class="lazyload" data-proofer-ignore></a></p>

<h4 id="332-a-算法"><span class="me-2">3.3.2. A* 算法</span><a href="#332-a-算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<p>$A^\star$ 算法（A-Star Algorithm）是一种启发式搜索算法，由Peter Hart、Nils Nilsson和Bertram Raphael于1968年提出。它结合了 Dijkstra 算法的完备性和贪婪最佳优先搜索的效率。</p>

<p>A* 算法的评估函数设计如下所示：</p>

\[f(n) = g(n) + h(n)\]

<p>其中 ，$g(n)$ 是从初始节点到当前节点已经获知的实际代价，由 Dijkstra 算法计算得到 ；$h(n)$ 是从当前节点到目标节点的估计代价。</p>

<p>启发函数作为估计代价 $h(n)$，需要具备如下两个性质：</p>

<ul>
  <li>
    <p><strong>可采纳性</strong>（Admissibility）：$h(n)$ 值必须小于等于从 $n$ 到目标节点的实际代价 $h(n) \leq h^\star(n)$，其中 $h^\star(n)$ 是从 $n$ 到目标节点的真实代价。</p>

    <ul>
      <li>
        <p>永远不要高估到达目标的代价，启发函数必须是一个乐观的估计（低估代价）；</p>
      </li>
      <li>
        <p>在网格路径规划中，可采纳的启发函数就如前述提到的曼哈顿距离或欧几里得距离；</p>
      </li>
      <li>
        <p>可采纳性保证A*找到最优解。</p>
      </li>
    </ul>

    <details>
      <summary>
<font color="blue">思考：如果使用不可采纳（非乐观估计）的启发函数会导致什么？</font>

</summary>

      <font color="blue">可能找到次优解，完全错过最优解。
  
如下图，最优解为 $A\to B \to C$，代价 。
  
当走到节点 $B$ 时，真实 $h^\star(B)=1$；
  
若 $h(B)=8$ 则误导算法找到 ”最优解” 为 $A\to C$ 代价 10</font>

      <pre><code class="language-mermaid">graph LR
A -- 5 --&gt; B
A -- 10 --&gt; C
B -- 1 --&gt; C
</code></pre>

    </details>
  </li>
  <li>
    <p><strong>一致性</strong> (Completeness)：又被称为单调性。启发函数 $h(n)$ 是一致的，当且仅当对于图中任意节点 $n$ 和它的任一邻居 $n^\prime$，以及从 $n$ 到 $n^\prime$ 的代价 $c(n, n^\prime)$，满足以下条件：</p>

\[h(n) \leq c(n, n^\prime) + h(n^\prime)\]

    <p>并且对于目标节点 $G$ 满足</p>

\[h(G) = 0\]

    <ul>
      <li>一致性条件实际上就是数学中的三角不等式（可代入走迷宫等场景想象）；</li>
      <li>或者换个角度理解：启发函数的变化量（即坡度）应该小于真实代价（真实边权）；</li>
      <li>
        <p>或者换个角度理解：估计变化不能超过实际变化；</p>
      </li>
      <li>
        <p>举例：想象一下实际的地理位置。从北京到上海的直线距离（$h(北京)$），一定小于或等于从北京到南京的实际距离（$c(北京, 南京)$）加上从南京到上海的直线距离（$h(南京)$）。</p>

\[h(北京) \leq c(北京, 南京) + h(南京)\]
      </li>
      <li>思考下面三个例子，判断是否满足一致性条件：
        <ul>
          <li>
            <details>
              <summary>
<font color="blue">认为餐厅还有1000米远。走了200米后，觉得还有700米远。</font>
</summary>

              <p>不满足。$1000 \leq 200 + 700 \Rightarrow 1000 \leq 900$ 不满足一致性。一开始估计过于悲观保守了，估计远了。</p>

            </details>
          </li>
          <li>
            <details>
              <summary>
<font color="blue">认为餐厅还有1000米远。走了200米后，觉得还有800米远。</font>
</summary>

              <p>满足。一开始估计很准确。</p>

            </details>
          </li>
          <li>
            <details>
              <summary>
<font color="blue">认为餐厅还有1000米远。走了200米后，觉得还有900米远。</font>
</summary>

              <p>满足。一开始估计过于乐观了，认为自己距离餐厅比较近。</p>

            </details>
          </li>
          <li>
            <details>
              <summary>
<font color="blue">认为餐厅还有1000米远。走了200米后，觉得还有1200米远。</font>
</summary>

              <p>满足。虽然反直觉，感觉上”越走越远”很奇怪，但从数学上，一致性只要求逻辑自洽，不要求估计准确。初始估计 1000 米，走了 200 米后，认为还要 1200 米，这意味着你修正了之前的低估：原来 1000 米的估计太乐观了。虽然这样满足一致性，但启发函数质量很差，应该尽量设计启发函数，保证评估函数的变化与实际代价的变化方向一致且幅度合理。</p>

            </details>
          </li>
        </ul>
      </li>
      <li><u>性质 1</u>：如果一个启发式函数是一致的，那么它一定是可采纳的。一致性比可采纳性更强。
        <ul>
          <li>
            <details>
              <summary>
<font color="blue">思考：如何证明？</font>
</summary>

              <font color="blue">假设我们要证明从任意节点 $n$ 到目标 $G$ 的估计 $h(n)$ 不大于实际代价 $h^\star(n)$。根据一致性，我们可以写出一系列不等式</font>

\[\begin{aligned}
h(n) &amp;\leq c(n, n_1) + h(n_1)\\
&amp; \leq c(n, n_1) + c(n_1, n_2) + h(n_2)\\
&amp; \leq\cdots\\
&amp; \leq c(n, n_1) + c(n_1, n_2) + c(n_2, n_3) + \cdots + h(G)\\
&amp; =h^\star(n)
\end{aligned}\]

            </details>
          </li>
        </ul>
      </li>
      <li>
        <p><u>性质 2</u>：一致性保证了评估函数 $f$ 的值单调不减，保证搜索过程是平稳的：</p>

\[\begin{aligned}
f(n^\prime) &amp;= g(n) + c(n, n^\prime) + h(n^\prime)\\
    &amp;= [g(n) + h(n)] + [c(n, n^\prime) + h(n^\prime) - h(n)]\\
    &amp;= f(n) + [c(n, n^\prime) - (h(n) - h(n^\prime))] \leq f(n)
\end{aligned}\]

        <p>这意味着 $A^\star$ 算法在扩展节点时，是沿着一个 $f(n)$ 值的等值面（或非递减前沿）进行扩展的。它第一次访问到一个节点时，所使用的路径就是到达该节点的最短路径（即 $g(n)$ 已经是最小的）。</p>
      </li>
    </ul>
  </li>
</ul>

<h4 id="333-搜索流程"><span class="me-2">3.3.3. 搜索流程</span><a href="#333-搜索流程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<p>$A^\star$ 算法的搜索过程同样需要设置两个列表，分别为一个 open 列表和一个 close 列表。其中，open 列表保存已经生成但是还未处理的节点，close 列表保存已访问的节点。算法中每一步都需要根据评估函数重新排列 open 列表，这样循环中的每一步都只考虑 open 列表中的最小评估函数的节点。</p>

<p>以下面这个迷宫为例，演示 $A^\star$ 算法的搜索过程。其中绿色格子是起点，蓝色格子是障碍物，红色格子是终点。</p>

<p><a href="/assets/img/postsimg/20250917/a-star-1.jpg" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/a-star-1.jpg" alt="" class="lazyload" data-proofer-ignore></a></p>

<p>具体步骤如下：</p>

<ul>
  <li>从起点 S 开始，将 S 加入open 列表中，并设置其父节点为空；</li>
  <li>将 S 从 open 列表中弹出，移入 close 列表中；</li>
  <li>获取 当前节点 的所有邻接节点：
    <ul>
      <li>判断其是否为终点、障碍物点、或已在 open 列表中：
        <ul>
          <li>
            <p>若都不是，则加入 open 列表，并计算邻接节点的评估函数 $f=g+h$ 值。简便起见，将评估函数、实际代价、启发函数分别列写在方格内特定位置。假设水平或垂直移动一格代价为 10, 斜向移动一格代价为 14，启发函数为曼哈顿函数，箭头指向父节点</p>

            <p><a href="/assets/img/postsimg/20250917/a-star-3.jpg" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/a-star-3.jpg" alt="" class="lazyload" data-proofer-ignore></a></p>
          </li>
          <li>
            <p>若邻接节点已经在 open 列表中，则重新计算评估函数 $f$ 值并根据情况更新；</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>从 open 列表中选择评估函数 $f$ 最小的节点，并将其弹出，移入 close 列表中；</p>

    <ul>
      <li>
        <p>返回上一步重复操作（触发了已经在 open 列表中的分支）；</p>

        <ul>
          <li>这里当前节点邻居均在 open 列表中，或为障碍物；</li>
          <li>对于 当前节点正上方的邻居，重新计算评估函数 $f$ 值；</li>
          <li>实际上是计算 $g$ 值，因为格子的 $h$ 值是不变的。</li>
          <li><u>黄色路径</u>：当前节点代价为 $10$，纵向移动到上方邻居节点的代价为 $10$，合计代价为 $g=10+10=20$；</li>
          <li><u>蓝色路径</u>：原始的 $g=14$；</li>
          <li>$20 \leq 14$，导致新路径 $f$ 值更大，不更新；</li>
        </ul>

        <p><a href="/assets/img/postsimg/20250917/a-star-4.jpg" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/a-star-4.jpg" alt="" class="lazyload" data-proofer-ignore></a></p>

        <ul>
          <li>遍历所有邻居（红边框格子），完成上述操作；</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>重复上一步，弹出 $f$ 值最小的节点（若有多个则随机选一个），并将其加入 close 列表中，并进行搜索、更新；</p>

    <ul>
      <li>假设随机选择了下方的节点作为当前节点；</li>
      <li>当前节点左侧的邻居已经在 open 列表中，计算后无须更新 $f$；</li>
      <li>
        <p>当前节点下方的邻居移入 open 列表中，更新父节点，并计算 $f$；</p>

        <p><a href="/assets/img/postsimg/20250917/a-star-5.jpg" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/a-star-5.jpg" alt="" class="lazyload" data-proofer-ignore></a></p>
      </li>
    </ul>
  </li>
  <li>重复上一步，弹出 $f$ 值最小的节点
    <ul>
      <li>
        <p>此时当前节点为上方 $f=54$ 节点，与前述步骤镜像</p>

        <p><a href="/assets/img/postsimg/20250917/a-star-6.jpg" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/a-star-6.jpg" alt="" class="lazyload" data-proofer-ignore></a></p>
      </li>
    </ul>
  </li>
  <li>重复上一步，弹出 $f$ 值最小的节点
    <ul>
      <li>此时当前节点随机选为下方 $f=60$ 节点，发现其正下方邻居节点在 open 表中</li>
      <li>
        <p>计算 $g=20 &lt; 28$，更新 $f=80$，更新父节点;</p>

        <p><a href="/assets/img/postsimg/20250917/a-star-7.jpg" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/a-star-7.jpg" alt="" class="lazyload" data-proofer-ignore></a></p>
      </li>
    </ul>
  </li>
  <li>算法结束的标志为：
    <ul>
      <li>当前节点为终点，此时从终点回溯父节点，得到路径；</li>
      <li>遍历所有节点，但未找到终点；</li>
    </ul>

    <p><a href="/assets/img/postsimg/20250917/a-star-8.jpg" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/a-star-8.jpg" alt="" class="lazyload" data-proofer-ignore></a></p>
  </li>
</ul>

<h4 id="334-实例"><span class="me-2">3.3.4. 实例</span><a href="#334-实例" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<p>同样的无障碍场景，同样能够处理带权和斜向移动的算法，这里给出 Disktra 算法和 $A^\star$ 算法的比较：</p>

<p><a href="/assets/img/postsimg/20250917/a-star-compare.gif" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/a-star-compare.gif" alt="" class="lazyload" data-proofer-ignore></a></p>

<p><a href="/assets/img/postsimg/20250917/dijkstra-compare.gif" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/dijkstra-compare.gif" alt="" class="lazyload" data-proofer-ignore></a></p>

<h2 id="4-蒙特卡罗树搜索"><span class="me-2">4. 蒙特卡罗树搜索</span><a href="#4-蒙特卡罗树搜索" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2>

<h3 id="41-极大极小minimax搜索算法"><span class="me-2">4.1. 极大极小（minimax）搜索算法</span><a href="#41-极大极小minimax搜索算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<p>以围棋为例：</p>

<p><a href="/assets/img/postsimg/20250917/minimax.jpg" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/minimax.jpg" alt="minimax" class="lazyload" data-proofer-ignore></a></p>

<ul>
  <li>轮到黑棋，黑棋有 $b_1$ 和 $b_2$ 两手可选，白棋对于 $b_1$ 有 $w_1$ 和 $w_2$ 两手可选，白棋对于 $b_2$ 有 $w_3, w_4 w_5$ 三手可选；</li>
  <li>如果白棋够聪明，会在黑棋走 $b_1$ 的时候回应以 $w_2$，在黑棋走 $b_2$ 的时候回应以 $w_4$。所以走 $b_1$ 后黑棋的真实胜率是 $48\%$，走 $b_2$ 后黑棋的真实胜率是 $45\%$；</li>
  <li>黑棋的正解是 $b_1$。这就是 minimax 搜索的核心思想：在搜索树中，每次轮到黑棋走时，走对黑棋最有利的；轮到白棋走时，走对黑棋最不利的。由于围棋是零和游戏，这就可以达到最优解；</li>
  <li>这是一个由底往上的过程：先把搜索树画到我们<strong>可以承受的深度且得到胜率评估</strong>，然后逐层往上取最大值或最小值<strong>回溯</strong>，就可以看到双方的正解。</li>
</ul>

<p>如果想把 minimax 搜索运用到围棋上，立刻会遇到两个大问题：</p>

<ul>
  <li><strong>搜索树太广</strong>。棋盘太大了，每一方在每一步都有很多着法可选。</li>
  <li><strong>搜索树太深，且很难评估胜率</strong>。除非把搜索树走到终局，这意味着要走够三百多步（因为对于电脑来说，甚至很难判断何时才是双方都同意的终局，所以只能傻傻地填子，一直到双方都真的没地方可以走为止）。简单地说，搜索树也需要特别深。</li>
</ul>

<h3 id="42-蒙特卡罗树搜索"><span class="me-2">4.2. 蒙特卡罗树搜索</span><a href="#42-蒙特卡罗树搜索" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3>

<h4 id="421-蒙特卡罗方法"><span class="me-2">4.2.1. 蒙特卡罗方法</span><a href="#421-蒙特卡罗方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<p>蒙特卡洛方法：也称统计模拟法、统计试验法。是把概率现象作为研究对象的数值模拟方法。是按抽样调查法求取统计值来推定未知特性量的计算方法。</p>

<blockquote>
  <p>蒙特卡罗是摩纳哥的著名赌城，该法为表明其随机抽样的本质而命名。故适用于对离散系统进行计算仿真试验。在计算仿真中，通过构造一个和系统性能相近似的概率模型，并在数字计算机上进行随机试验，可以模拟系统的随机特性。</p>
</blockquote>

<p>通常采用蒙特卡罗方法求解的问题可以粗略地分成两类：</p>

<ul>
  <li>一类是所求解的问题本身具有内在的随机性，借助计算机的运算能力可以直接模拟这种随机过程。例如在核物理研究中，分析中子在反应堆中的传输过程。中子与原子核作用受到量子力学规律的制约，人们只能知道它们相互作用发生的概率，却无法准确获得中子与原子核作用时的位置以及裂变产生的新中子的行进速率和方向。科学家依据其概率进行随机抽样得到裂变位置、速度和方向，这样模拟大量中子的行为后，经过统计就能获得中子传输的范围，作为反应堆设计的依据。</li>
  <li>
    <p>另一种类型是所求解问题可以转化为某种随机分布的特征数，比如随机事件出现的概率，或者随机变量的期望值。通过随机抽样的方法，以随机事件出现的频率估计其概率，或者以抽样的数字特征估算随机变量的数字特征，并将其作为问题的解。这种方法多用于求解复杂的多维积分问题。</p>

    <ul>
      <li>比如计算任意函数的定积分：随机投点法、平均值法</li>
    </ul>
  </li>
</ul>

<h4 id="422-蒙特卡罗树搜索"><span class="me-2">4.2.2. 蒙特卡罗树搜索</span><a href="#422-蒙特卡罗树搜索" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4>

<p>1987 年 Bruce Abramson 在他的博士论文中提出了基于蒙特卡洛方法的树搜索（Monte Carlo Tree Search，MCTS）这一想法，是一种基于树数据结构、能权衡探索与利用、在搜索空间巨大仍然比较有效的的搜索算法。</p>

<blockquote>
  <p>MCTS 只适用于组合博弈（Combinatorial Game）的问题。</p>

  <p>博弈论中，我们把零和、信息对称、确定性、离散、序列的游戏统称为 组合博弈。</p>

  <ul>
    <li>
      <p>零和（zero-sum）：一方的收益必然意味着另一方的损失，收益和损失相加总和永远为零，故双方不存在合作的可能</p>
    </li>
    <li>
      <p>信息对称（perfect information）：游戏的所有信息、状态、规则都是所有玩家已知的；</p>
    </li>
    <li>
      <p>确定性（deterministic）：游戏终将结束，且有特定的判定规则判断输赢；</p>
    </li>
    <li>
      <p>离散（discrete）：博弈状态是有限的集合（如棋盘大小和落子位置）；</p>
    </li>
    <li>
      <p>序列（sequential）：博弈过程是序列进行的，双方轮流操作。</p>
    </li>
  </ul>
</blockquote>

<p>以取火柴游戏为例，有一堆 $n$ 个火柴，两人轮流从堆中取，每次取 $x$ 个（ $1 \leq x \leq n$），最后取光者为胜。或有若干堆火柴，两人轮流从中拿取，每次只能从一堆中取若干根，不可不取，最后取完者为胜。</p>

<p>以围棋为例，这类算法要解决的问题是这样的，我们把围棋的每一步所有可能选择都作为树的节点，第零层只有 1 个根节点，第 1 层就有  361 种下子可能和节点，第 2 层有 360 种下子可能和节点，这是一颗非常大的树，我们要在每一层树节点中搜索出赢概率最大的节点，也就是下子方法。</p>

<p>蒙特卡罗树搜索如何解决 之前 minimax 搜索算法应用于围棋领域的问题呢？</p>

<ul>
  <li><strong>搜索树太广</strong>：根据它的设计，搜索树会较好地自动集中到“更值得搜索的变化”（注意，也不一定准）。如果发现一个不错的着法，蒙特卡洛树搜索会较快地把它看到很深，可以说它结合了广度优先搜索和深度优先搜索，类似于启发式搜索。这就部分解决了第一个问题；</li>
  <li><strong>搜索树太深，且很难评估胜率</strong>：它可以给出一个局面评估，虽然不准，但比没有强。这就部分解决了第二个问题。</li>
</ul>

<p>观察如下围棋对局的过程，图中每个节点代表一个局面。而 $x/y$ 代表这个节点被访问 $y$ 次，其中黑棋胜利了 $x$ 次。例如一开始的根节点是 $12/21$，代表总共模拟了 $21$ 次，黑棋胜利了 $12$ 次。</p>

<p><a href="/assets/img/postsimg/20250917/mcts-1.jpg" class="popup img-link "><img data-src="/assets/img/postsimg/20250917/mcts-1.jpg" alt="mcts-1" class="lazyload" data-proofer-ignore></a></p>

<p>MCTS 的主要步骤是选择、扩展、模拟（评估）、回溯：</p>

<ul>
  <li><strong>选择</strong>（Selection）：从根节点往下走，每次都选一个 “最值得看的子节点”（具体规则稍后说），直到来到一个 “存在未扩展的子节点” 的节点，如图中的 $3/3$ 节点。“存在未扩展的子节点” 其实就是指这个局面存在未走过的后续走法；</li>
  <li><strong>扩展</strong>（Expansion）：给这个节点加上一个 $0/0$ 子节点，对应之前所说的 “未扩展的子节点”，就是还没有试过的一个着法。</li>
  <li><strong>模拟</strong>（Simluation）：或称为评估。从没有试过的走法开始，用快速走子策略（Rollout policy）走到底，得到一个胜负结果。快速走子策略适合选择一个棋力很弱但走子很快的策略。因为如果这个策略走得慢，虽然棋力会更强，结果会更准确，但由于耗时多了，在单位时间内的模拟次数就少了，所以不一定会棋力更强，有可能会更弱。这也是为什么我们一般只模拟一次，因为如果模拟多次，虽然更准确，但更慢；</li>
  <li><strong>回溯</strong>（Backpropagation），把模拟的结果加到它的所有父节点上。例如第三步模拟的结果是 $0/1$（代表黑棋失败），那么就把这个节点的所有父节点都加上 $0/1$。</li>
</ul>

<p>我们回过头来分析选择过程，注意到前面提及需要选择一个 “最值得看的子节点”。假设对于一个局面（根节点），可供选择的情况有三种可能：</p>

<ul>
  <li>该节点所有子节点都已经被扩展过</li>
  <li>该节点有子节点还未被扩展过</li>
  <li>这个节点游戏已经结束了</li>
</ul>

<details>
  <summary>
    <font color="blue">思考：用快速走子解决深度问题，那么能否用 minmax 选择 “最值得看的子节点” ？</font>
  </summary>

  <font color="blue">不能太贪心，不能每次都只选择 “最有利的/最不利的”，因为这会意味着搜索树的广度不够，容易忽略实际更好的选择。</font>

</details>

<p>MCTS 提出了一个选择策略，计算置信区间上界（Upper Confidence Bound，UCB）作为选择依据：</p>

\[\text{UCB}(v_i, v) = \underbrace{\frac{x(v_i)}{y(v_i)}}_{利用} + \underbrace{c \times \sqrt{\frac{\log y(v)}{y(v_i)}}}_{探索}\]

<p>其中，第一项计算了节点 $v_i$ 的平均胜率，胜率越高被选择的概率就应该越大；第二项表示对访问次数较少的节点的探索鼓励，若某个节点访问次数 $y(v_i)$ 比较少，则该项值越大。公式中的常数 $c$ 可以根据问题调整，一般取 $\sqrt{2}$。​</p>

<p>因此，若：</p>

<ul>
  <li>
    <p>该节点所有子节点都已经被扩展过</p>

    <ul>
      <li>使用 UCB 公式选择一个值最大的子节点继续向下搜索。</li>
    </ul>
  </li>
  <li>
    <p>该节点有子节点还未被扩展过</p>

    <ul>
      <li>转向扩展（Expansion） 步骤，扩展一个未访问的子节点。</li>
    </ul>
  </li>
  <li>
    <p>这个节点游戏已经结束了</p>

    <ul>
      <li>直接回溯游戏结果。</li>
    </ul>
  </li>
</ul>

<p>对于模拟（评估）步骤，引入了快速走子策略走到底，得到一个胜负结果，这里快速走子策略可以有多种选择：</p>

<ul>
  <li>基于规则库的专家算法</li>
  <li>深度学习预训练模型</li>
</ul>

</div>

<div class="post-tail-wrapper text-muted">

  <!-- categories -->
  
  <div class="post-meta mb-3">
    <i class="far fa-folder-open fa-fw me-1"></i>
    
      <a href='/categories/academic/'>Academic</a>,
      <a href='/categories/knowledge/'>Knowledge</a>
  </div>
  

  <!-- tags -->
  
  <div class="post-tags">
    <i class="fa fa-tags fa-fw me-1"></i>
      
      <a href="/tags/artificial-intelligence/"
          class="post-tag no-text-decoration" >artificial intelligence</a>
      
  </div>
  

  <div class="post-tail-bottom
    d-flex justify-content-between align-items-center mt-3 pt-5 pb-2">
    <div class="license-wrapper">

      

        

        本文由作者按照 
        <a href="https://creativecommons.org/licenses/by/4.0/">
          CC BY 4.0
        </a>
         进行授权

      
    </div>

    <!-- Post sharing snippet -->

<div class="share-wrapper">
  <span class="share-label text-muted me-1">分享</span>
  <span class="share-icons">
    
    
    

    
      
      <a
        href="https://twitter.com/intent/tweet?text=%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%EF%BC%88%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5%EF%BC%89%20-%20SIRLIS&url=http%3A%2F%2Flocalhost%3A4000%2Fposts%2Fartificial-intelligence-search-strategy%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Twitter"
        target="_blank"
        rel="noopener"
        aria-label="Twitter"
      >
        <i class="fa-fw fab fa-twitter"></i>
      </a>
    
      
      <a
        href="https://www.facebook.com/sharer/sharer.php?title=%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%EF%BC%88%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5%EF%BC%89%20-%20SIRLIS&u=http%3A%2F%2Flocalhost%3A4000%2Fposts%2Fartificial-intelligence-search-strategy%2F"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Facebook"
        target="_blank"
        rel="noopener"
        aria-label="Facebook"
      >
        <i class="fa-fw fab fa-facebook-square"></i>
      </a>
    
      
      <a
        href="https://t.me/share/url?url=http%3A%2F%2Flocalhost%3A4000%2Fposts%2Fartificial-intelligence-search-strategy%2F&text=%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%EF%BC%88%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5%EF%BC%89%20-%20SIRLIS"
        data-bs-toggle="tooltip"
        data-bs-placement="top"
        title="Telegram"
        target="_blank"
        rel="noopener"
        aria-label="Telegram"
      >
        <i class="fa-fw fab fa-telegram"></i>
      </a>
    

    <i
      id="copy-link"
      class="fa-fw fas fa-link small"
      data-bs-toggle="tooltip"
      data-bs-placement="top"
      title="分享链接"
      data-title-succeed="链接已复制！"
    >
    </i>
  </span>
</div>


  </div><!-- .post-tail-bottom -->

</div><!-- div.post-tail-wrapper -->


      
    
      
    </div>
  </div>
  <!-- #core-wrapper -->

  <!-- panel -->
  <div id="panel-wrapper" class="col-xl-3 ps-2 text-muted">
    <div class="access">
      <!-- Get the last 5 posts from lastmod list. -->














  <div id="access-lastmod" class="post">
    <div class="panel-heading">最近更新</div>
    <ul class="post-content list-unstyled ps-0 pb-1 ms-1 mt-2">
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/Pattern-Recognition-CNN/">模式识别（卷积神经网络）</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/reinforcement-learning-Policy-Gradient/">强化学习（策略梯度法）</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/reinforcement-learning-Value-Approximation/">强化学习（值函数近似）</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/deep-learning-RNN/">深度学习基础（RNN）</a>
        </li>
      
        
        
        
        <li class="text-truncate lh-lg">
          <a href="/posts/deep-learning-LSTM/">深度学习基础（LSTM）</a>
        </li>
      
    </ul>
  </div>
  <!-- #access-lastmod -->


      <!-- The trending tags list -->















  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
      
        
        

  
    
    
    
    
      
    
  
    
    
    
    
      
        
        

  
    
    
    
    
      
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
      
        
        



  <div id="access-tags">
    <div class="panel-heading">热门标签</div>
    <div class="d-flex flex-wrap mt-3 mb-1 me-3">
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/deep-learning/">deep learning</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/python/">python</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/fuzzy/">fuzzy</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/pattern-recognition/">pattern recognition</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/vscode/">vscode</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/reinforcement-learning/">reinforcement learning</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/other/">other</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/artificial-intelligence/">artificial intelligence</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/astronomy/">astronomy</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/c-c/">c/c++</a>
      
    </div>
  </div>


    </div>

    
      
      



  <div id="toc-wrapper" class="ps-0 pe-4 mb-5">
    <div class="panel-heading ps-3 pt-2 mb-2">文章内容</div>
    <nav id="toc"></nav>
  </div>


    
  </div>
</div>

<!-- tail -->

  <div class="row">
    <div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-3 pe-xl-4 mt-5">
      
        
        <!--
  Recommend the other 3 posts according to the tags and categories of the current post,
  if the number is not enough, use the other latest posts to supplement.
-->

<!-- The total size of related posts -->


<!-- An random integer that bigger than 0 -->


<!-- Equals to TAG_SCORE / {max_categories_hierarchy} -->








  

  
    
  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  






<!-- Fill with the other newlest posts -->





  <div id="related-posts" class="mb-2 mb-sm-4">
    <h3 class="pt-2 mb-4 ms-1" data-toc-skip>
      相关文章
    </h3>
    <div class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4">
      
        
        
        <div class="col">
          <a href="/posts/artificial-intelligence-introduction/" class="card post-preview h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->





<em
  class="small"
  data-ts="1753959469"
  data-df="YYYY/MM/DD"
  
>
  2025/07/31
</em>

              <h4 class="pt-0 my-2" data-toc-skip>人工智能（绪论）</h4>
              <div class="text-muted small">
                <p>
                  





                  绪论。




  1. 什么是人工智能
    
      1.1. 人工智能
      1.2. 机器学习
      1.3. 深度学习
      1.4. 模式识别
      1.5. 关系图
    
  
  2. 人工智能的发展历史
    
      2.1. 萌芽与理论探索期
        
          2.1.1. 图灵测试
        
    ...
                </p>
              </div>
            </div>
          </a>
        </div>
      
        
        
        <div class="col">
          <a href="/posts/reinforcement-learning-Value-Approximation/" class="card post-preview h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->





<em
  class="small"
  data-ts="1672654339"
  data-df="YYYY/MM/DD"
  
>
  2023/01/02
</em>

              <h4 class="pt-0 my-2" data-toc-skip>强化学习（值函数近似）</h4>
              <div class="text-muted small">
                <p>
                  





                  本文首先介绍了值函数近似（Value Approximation），然后分别结合 SARSA 和 Q-Learning 给出了两种 Q 函数近似的方法。通过分析线性函数作为估计函数的局限性，自然引入神经网络来进行非线性函数近似，引出了基于深度学习的 Q 函数估计网络：Deep Q-Network（DQN）。






  1. 引言
  2. 状态价值函数近似
    
      2.1...
                </p>
              </div>
            </div>
          </a>
        </div>
      
        
        
        <div class="col">
          <a href="/posts/artificial-intelligence-knowledge-etc/" class="card post-preview h-100">
            <div class="card-body">
              <!--
  Date format snippet
  See: ${JS_ROOT}/utils/locale-dateime.js
-->





<em
  class="small"
  data-ts="1756004629"
  data-df="YYYY/MM/DD"
  
>
  2025/08/24
</em>

              <h4 class="pt-0 my-2" data-toc-skip>人工智能（知识表示与推理）</h4>
              <div class="text-muted small">
                <p>
                  





                  在人工智能与知识管理领域，对知识的系统性认知与高效表示是实现智能推理和决策的基础。本文将从知识的本质出发，首先剖析知识的基本概念，明确其定义与分类，为后续探讨知识的表示与推理奠定理论基石；继而深入解析基于符号逻辑的多种知识表示方法，包括一阶谓词逻辑、产生式规则、框架式表示等经典范式，揭示逻辑推理的内在机制；同时，结合语义网技术，阐述以 RDF 为核心的知识表示体系及其在语义建模中的应用。通过...
                </p>
              </div>
            </div>
          </a>
        </div>
      
    </div>
    <!-- .card-deck -->
  </div>
  <!-- #related-posts -->


      
        
        <!-- Navigation buttons at the bottom of the post. -->

<div class="post-navigation d-flex justify-content-between">
  
    <a
      href="/posts/artificial-intelligence-knowledge-etc/"
      class="btn btn-outline-primary"
      prompt="上一篇"
    >
      <p>人工智能（知识表示与推理）</p>
    </a>
  

  
    <div
      class="btn btn-outline-primary disabled"
      prompt="下一篇"
    >
      <p>-</p>
    </div>
  
</div>

      
        
        <!--  The comments switcher -->

  
  <!-- https://utteranc.es/ -->
<script src="https://utteranc.es/client.js"
        repo="sirlis/sirlis.github.io"
        issue-term="pathname"
        crossorigin="anonymous"
        async>
</script>

<script type="text/javascript">
  $(function() {
    const origin = "https://utteranc.es";
    const iframe = "iframe.utterances-frame";
    const lightTheme = "github-light";
    const darkTheme = "github-dark";
    let initTheme = lightTheme;

    if ($("html[data-mode=dark]").length > 0
        || ($("html[data-mode]").length == 0
            && window.matchMedia("(prefers-color-scheme: dark)").matches)) {
      initTheme = darkTheme;
    }

    addEventListener("message", (event) => {
      let theme;

      /* credit to <https://github.com/utterance/utterances/issues/170#issuecomment-594036347> */
      if (event.origin === origin) {
        /* page initial */
        theme = initTheme;

      } else if (event.source === window && event.data &&
            event.data.direction === ModeToggle.ID) {
        /* global theme mode changed */
        const mode = event.data.message;
        theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme);

      } else {
        return;
      }

      const message = {
        type: "set-theme",
        theme: theme
      };

      const utterances = document.querySelector(iframe).contentWindow;
      utterances.postMessage(message, origin);
    });

  });
</script>



      
    </div>
  </div>


        <!-- The Search results -->

<div id="search-result-wrapper" class="d-flex justify-content-center unloaded">
  <div class="col-11 post-content">
    <div id="search-hints">
      <!-- The trending tags list -->















  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
  
    
    
    
    
      
        
        

  
    
    
    
    
      
        
        

  
    
    
    
    
      
    
  
    
    
    
    
      
        
        

  
    
    
    
    
      
    
  
    
    
    
    
      
    
  
    
    
    
    
  
    
    
    
    
      
        
        



  <div id="access-tags">
    <div class="panel-heading">热门标签</div>
    <div class="d-flex flex-wrap mt-3 mb-1 me-3">
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/deep-learning/">deep learning</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/python/">python</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/fuzzy/">fuzzy</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/pattern-recognition/">pattern recognition</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/vscode/">vscode</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/reinforcement-learning/">reinforcement learning</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/other/">other</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/artificial-intelligence/">artificial intelligence</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/astronomy/">astronomy</a>
      
        
        <a class="post-tag btn btn-outline-primary" href="/tags/c-c/">c/c++</a>
      
    </div>
  </div>


    </div>
    <div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div>
  </div>
</div>

      </div>
    </div>

    <!-- The Footer -->

<footer>
  <div class="container px-lg-4">
    <div class="d-flex justify-content-center align-items-center text-muted mx-md-3">
      <p>本站采用 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 主题 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a>
      </p>

      <p>©
        2025
        <a href="https://github.com/sirlis">sirlis</a>.
        
          <span
            data-bs-toggle="tooltip"
            data-bs-placement="top"
            title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。"
          >保留部分权利。</span>
        
      </p>
    </div>
  </div>
</footer>


    <div id="mask"></div>

    <button id="back-to-top" aria-label="back-to-top" class="btn btn-lg btn-box-shadow">
      <i class="fas fa-angle-up"></i>
    </button>

    
      <div
        id="notification"
        class="toast"
        role="alert"
        aria-live="assertive"
        aria-atomic="true"
        data-bs-animation="true"
        data-bs-autohide="false"
      >
        <div class="toast-header">
          <button
            type="button"
            class="btn-close ms-auto"
            data-bs-dismiss="toast"
            aria-label="Close"
          ></button>
        </div>
        <div class="toast-body text-center pt-0">
          <p class="px-2 mb-3">发现新版本的内容。</p>
          <button type="button" class="btn btn-primary" aria-label="Update">
            更新
          </button>
        </div>
      </div>
    

    <!-- JS selector for site. -->

<!-- commons -->



<!-- layout specified -->


  

  
    <!-- image lazy-loading & popup & clipboard -->
    
  















  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  

  
    

    

  



  <script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.0/dist/jquery.min.js,npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.7/dayjs.min.js,npm/dayjs@1.11.7/locale/zh.min.js,npm/dayjs@1.11.7/plugin/relativeTime.min.js,npm/dayjs@1.11.7/plugin/localizedFormat.min.js,npm/tocbot@4.21.0/dist/tocbot.min.js,npm/mermaid@9.4.3/dist/mermaid.min.js"></script>






<script defer src="/assets/js/dist/post.min.js"></script>


  <!-- MathJax -->
  <script>
    /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */
    MathJax = {
      tex: {
        /* start/end delimiter pairs for in-line math */
        inlineMath: [
          ['$', '$'],
          ['\\(', '\\)']
        ],
        /* start/end delimiter pairs for display math */
        displayMath: [
          ['$$', '$$'],
          ['\\[', '\\]']
        ]
      }
    };
  </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-chtml.js"></script>





    
      <!-- mermaid-js loader -->
<script type="text/javascript">
  (function () {
    function updateMermaid(event) {
      if (event.source === window && event.data && event.data.direction === ModeToggle.ID) {
        const mode = event.data.message;

        if (typeof mermaid === 'undefined') {
          return;
        }

        let expectedTheme = mode === ModeToggle.DARK_MODE ? 'dark' : 'default';
        let config = { theme: expectedTheme };

        /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */
        $('.mermaid').each(function () {
          let svgCode = $(this).prev().children().html();
          $(this).removeAttr('data-processed');
          $(this).html(svgCode);
        });

        mermaid.initialize(config);
        mermaid.init(undefined, '.mermaid');
      }
    }

    let initTheme = 'default';
    const html = document.documentElement;

    if (
      (html.hasAttribute('data-mode') && html.getAttribute('data-mode') === 'dark') ||
      (!html.hasAttribute('data-mode') && window.matchMedia('(prefers-color-scheme: dark)').matches)
    ) {
      initTheme = 'dark';
    }

    let mermaidConf = {
      theme: initTheme /* <default|dark|forest|neutral> */
    };

    /* Create mermaid tag */
    document.querySelectorAll('pre>code.language-mermaid').forEach((elem) => {
      const svgCode = elem.textContent;
      const backup = elem.parentElement;
      backup.classList.add('unloaded');
      /* create mermaid node */
      let mermaid = document.createElement('pre');
      mermaid.classList.add('mermaid');
      const text = document.createTextNode(svgCode);
      mermaid.appendChild(text);
      backup.after(mermaid);
    });

    mermaid.initialize(mermaidConf);

    window.addEventListener('message', updateMermaid);
  })();
</script>

    

    <!--
  Jekyll Simple Search loader
  See: <https://github.com/christian-fei/Simple-Jekyll-Search>
-->





<script>
  /* Note: dependent library will be loaded in `js-selector.html` */
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('search-results'),
    json: '/assets/js/data/search.json',
    searchResultTemplate: '<div class="px-1 px-sm-2 px-lg-4 px-xl-0">  <a href="{url}">{title}</a>  <div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1">    {categories}    {tags}  </div>  <p>{snippet}</p></div>',
    noResultsText: '<p class="mt-5"></p>',
    templateMiddleware: function(prop, value, template) {
      if (prop === 'categories') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`;
        }
      }

      if (prop === 'tags') {
        if (value === '') {
          return `${value}`;
        } else {
          return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`;
        }
      }
    }
  });
</script>

  </body>
</html>

